#!/bin/env python3
#

import os
import os.path
import itertools as it
import dataclasses as dc

osid_lock = it.count()
def next_osid ():
  return next(osid_lock)

@dc.dataclass
class DNode:
  name_fold : str
  path_fold : str
  node_list : list = dc.field(default_factory = list)
  node_osid : int = dc.field(default_factory = next_osid)

@dc.dataclass
class FNode:
  name_fold : str
  path_fold : str
  path_real : str
  node_osid : int = dc.field(default_factory = next_osid)

def foldcase (what):
  return str(what).lower()

# We case-fold and merge the directory tree (dtree). 
# We case-fold files and place them into appropriate case-folded directories.
# We care about the actual paths in the filesystem to the individual files.

def pathwrap (path):
  return os.path.realpath(os.path.join('/', path))

def processlayer (lpath, dtree, ftree):
  for (rpath, dlist, flist) in os.walk(lpath):
    rfold = pathwrap(foldcase(os.path.relpath(rpath, lpath)))
    if rfold in dtree:
      rnode = dtree.get(rfold)
    else:
      rname = os.path.basename(rfold)
      rnode = DNode(
        name_fold = rname,
        path_fold = rfold
      )
      dtree[rfold] = rnode
    
    for dname in dlist:
      dname = foldcase(dname)
      dfold = pathwrap(os.path.join(rfold, dname))
      if dfold not in dtree:
        dnode = DNode(
          name_fold = dname,
          path_fold = dfold
        )
        rnode.node_list.append(dnode)
        dtree[dfold] = dnode

    for fname in flist:
      fpath = os.path.join(rpath, fname)
      fname = foldcase(fname)
      ffold = pathwrap(os.path.join(rfold, fname))

      if ffold in ftree:
        fnode = ftree.get(ffold)
        fnode.path_real = fpath
      else:
        fnode = FNode(
          name_fold = fname,
          path_fold = ffold,
          path_real = fpath
        )
        rnode.node_list.append(fnode)
        ftree[ffold] = fnode

dtree = dict()
ftree = dict()
llist = [
  '/tmp/fuss/testdir/1',
  '/tmp/fuss/testdir/2',
  '/tmp/fuss/testdir/3',
  '/tmp/fuss/testdir/4',
]

#dtree['/'] = DNode(
#  name_fold = '/',
#  path_fold = '/'
#)

for lpath in llist:
  processlayer(lpath, dtree, ftree)

for dnode in dtree.values():
  print(dnode.name_fold, ':', dnode.path_fold)
for fnode in ftree.values():
  print(fnode.name_fold, ':', fnode.path_fold)

import fuse
import errno
import stat

fuse.fuse_python_api = (0, 2)

def getattr_dnode (node):
  info = fuse.Stat()
  info.st_mode = stat.S_IFDIR | 0o500
  info.st_ino = node.node_osid
  info.st_nlink = len(node.node_list)
  return info

def getattr_fnode (node):
  info = fuse.Stat()
  info.st_mode = stat.S_IFREG | 0o400
  info.st_ino = node.node_osid
  info.st_size = os.path.getsize(node.path_real)
  info.st_nlink = 1
  return info

class ROCFOMFS (fuse.Fuse):
  def getattr (self, path):
    if path in dtree:
      return getattr_dnode(dtree.get(path))
    if path in ftree:
      return getattr_fnode(ftree.get(path))
    return - errno.ENOENT

  def access (self, path, mode):
    if path in dtree:
      return 0
    if path in ftree:
      return 0
    return - errno.ENOENT

  def readdir (self, path, offset):
    if path not in dtree:
      return
    dnode = dtree.get(path)
    for node in dnode.node_list:
      yield fuse.Direntry(node.name_fold)
    yield fuse.Direntry('.')
    yield fuse.Direntry('..')

  class ROCFOMFSFile:
    def __init__ (self, path, flags, * mode):
      self.path = path
      self.node = ftree.get(path)

    def fgetattr (self):
      return getattr_fnode(self.node)
    def read (self, length, offset):
      with open(self.node.path_real, 'rb') as file:
        file.seek(offset)
        return file.read(length)
      
  def __init__ (self):
    fuse.Fuse.__init__(self)
    self.file_class = self.ROCFOMFSFile
  

s = ROCFOMFS()
s.parse()
s.main()

