#!/bin/env python3
#

import os
import os.path
import itertools as it
import dataclasses as dc

osid_lock = it.count()
def next_osid ():
  return next(osid_lock)

@dc.dataclass
class DNode:
  name_fold : str
  path_fold : str
  node_list : list = dc.field(default_factory = list)
  node_osid : int = dc.field(default_factory = next_osid)

@dc.dataclass
class FNode:
  name_fold : str
  path_fold : str
  path_real : str
  node_osid : int = dc.field(default_factory = next_osid)

def foldcase (what):
  return str(what).lower()

def normpath (path):
  return os.path.normpath(os.path.join('/', path))

# We case-fold and merge the directory tree (dtree). 
# We case-fold files and place them into appropriate case-folded directories.
# We care about the actual paths in the filesystem to the individual files.

def processlayer (lpath, dtree, ftree):
  for (rpath, dlist, flist) in os.walk(lpath):
    rfold = normpath(foldcase(os.path.relpath(rpath, lpath)))
    if rfold in dtree:
      rnode = dtree.get(rfold)
    else:
      rname = os.path.basename(rfold)
      rnode = DNode(
        name_fold = rname,
        path_fold = rfold
      )
      dtree[rfold] = rnode
    
    for dname in dlist:
      dname = foldcase(dname)
      dfold = normpath(os.path.join(rfold, dname))
      if dfold not in dtree:
        dnode = DNode(
          name_fold = dname,
          path_fold = dfold
        )
        rnode.node_list.append(dnode)
        dtree[dfold] = dnode

    for fname in flist:
      fpath = os.path.join(rpath, fname)
      fname = foldcase(fname)
      ffold = normpath(os.path.join(rfold, fname))

      if ffold in ftree:
        fnode = ftree.get(ffold)
        fnode.path_real = fpath
      else:
        fnode = FNode(
          name_fold = fname,
          path_fold = ffold,
          path_real = fpath
        )
        rnode.node_list.append(fnode)
        ftree[ffold] = fnode

import fuse
import stat
import errno

fuse.fuse_python_api = (0, 2)

def getattr_dnode (node):
  info = fuse.Stat()
  info.st_mode = stat.S_IFDIR | 0o500
  info.st_ino = node.node_osid
  info.st_size = len(node.node_list)
  info.st_nlink = len(node.node_list)
  return info

def getattr_fnode (node):
  info = fuse.Stat()
  info.st_mode = stat.S_IFREG | 0o400
  info.st_ino = node.node_osid
  info.st_size = os.path.getsize(node.path_real)
  info.st_nlink = 1
  return info

class ROCFOMFS (fuse.Fuse):
  def getattr (self, path):
    path = foldcase(path)
    if path in dtree:
      return getattr_dnode(dtree.get(path))
    if path in ftree:
      return getattr_fnode(ftree.get(path))
    return - errno.ENOENT

  def access (self, path, mode):
    path = foldcase(path)
    if path in dtree:
      return 0
    if path in ftree:
      return 0
    return - errno.ENOENT

  def readdir (self, path, offset):
    path = foldcase(path)
    if path not in dtree:
      return
    dnode = dtree.get(path)
    for node in dnode.node_list:
      yield fuse.Direntry(node.name_fold)
    yield fuse.Direntry('.')
    yield fuse.Direntry('..')

  class ROCFOMFSFile:
    def __init__ (self, path, flags, * mode):
      self.path = foldcase(path)
      self.node = ftree.get(self.path)

    def fgetattr (self):
      return getattr_fnode(self.node)
    def read (self, length, offset):
      with open(self.node.path_real, 'rb') as file:
        file.seek(offset)
        return file.read(length)
      
  def __init__ (self):
    fuse.Fuse.__init__(self)
    self.file_class = self.ROCFOMFSFile

dtree = dict()
ftree = dict()

llist = [
  '/tmp/fallout-4-gog-vanilla/Data/',
  'mods/CBBE',
  'mods/BDOHair',
  'mods/TrueStorms',
  'mods/LongerPowerLines',
  'mods/ScrapEverything'
]

for lpath in llist:
  lpath = os.path.abspath(lpath)
  processlayer(lpath, dtree, ftree)

server = ROCFOMFS()
server.parse()
server.main()

